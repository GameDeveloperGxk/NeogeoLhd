/**
  * Generated by smali2java 1.0.0.558
  * Copyright (C) 2013 Hensence.com
  */

package com.squareup.picasso;

import java.util.concurrent.atomic.AtomicInteger;
import java.util.List;
import java.util.concurrent.Future;
import android.graphics.Bitmap;
import android.os.Handler;
import java.util.Iterator;
import java.io.InputStream;
import java.io.IOException;
import android.graphics.BitmapFactory;
import android.graphics.Matrix;
import android.net.NetworkInfo;

class BitmapHunter implements Runnable {
    Action action;
    List<Action> actions;
    final Cache cache;
    final Request data;
    final Dispatcher dispatcher;
    Exception exception;
    int exifRotation;
    Future<?> future;
    final String key;
    Picasso.LoadedFrom loadedFrom;
    final int memoryPolicy;
    int networkPolicy;
    final Picasso picasso;
    Picasso.Priority priority;
    final RequestHandler requestHandler;
    Bitmap result;
    int retryCount;
    final int sequence;
    final Stats stats;
    private static final Object DECODE_LOCK = localBitmapHunter.21;
    localBitmapHunter.21.super();
    private static final ThreadLocal<StringBuilder> NAME_BUILDER = new ThreadLocal() {
        
        protected StringBuilder initialValue() {
            return ("Picasso-");
        }
    };
    private static final AtomicInteger SEQUENCE_GENERATOR = new AtomicInteger();
    private static final RequestHandler ERRORING_HANDLER = new RequestHandler() {
        
        public boolean canHandleRequest(Request p1) {
            return true;
        }
        
        public RequestHandler.Result load(Request p1, int p2) throws IOException {
            throw new IllegalStateException("Unrecognized type of request: " + p1);
        }
    };
    
    BitmapHunter(Picasso p1, Dispatcher p2, Cache p3, Stats p4, Action p5, RequestHandler p6) {
        sequence = SEQUENCE_GENERATOR.incrementAndGet();
        picasso = p1;
        dispatcher = p2;
        cache = p3;
        stats = p4;
        action = p5;
        key = p5.getKey();
        data = p5.getRequest();
        priority = p5.getPriority();
        memoryPolicy = p5.getMemoryPolicy();
        networkPolicy = p5.getNetworkPolicy();
        requestHandler = p6;
        retryCount = p6.getRetryCount();
    }
    
    static Bitmap decodeStream(InputStream p1, Request p2) throws IOException {
        // :( Parsing error. Please contact me.
    }
    
    public void run() {
        // :( Parsing error. Please contact me.
    }
    
    Bitmap hunt() throws IOException {
        int localconst/41 = 0x0;
        if(MemoryPolicy.shouldReadFromMemoryCache(memoryPolicy)) {
            cache = cache.get(key);
            if(cache != null) {
                stats.dispatchCacheHit();
                loadedFrom = Picasso.LoadedFrom.MEMORY;
                if(picasso.loggingEnabled) {
                    Utils.log("Hunter", "decoded", data.logId(), "from cache");
                    return cache;
                }
            }
        }
        data.networkPolicy = networkPolicy;
        requestHandler = requestHandler.load(data, networkPolicy);
        if(requestHandler != null) {
            loadedFrom = requestHandler.getLoadedFrom();
            exifRotation = requestHandler.getExifOrientation();
            localint2 = requestHandler.getBitmap();
            if(requestHandler.getExifOrientation() == 0) {
                requestHandler = requestHandler.getStream();
                data = decodeStream(requestHandler, data);
                Utils.closeQuietly(requestHandler);
            }
        }
        if(localconst/41 != null) {
            if(picasso.loggingEnabled) {
                Utils.log("Hunter", "decoded", data.logId());
            }
            stats.dispatchBitmapDecoded(localconst/41);
            if((data.needsTransformation()) || (exifRotation != 0)) {
                synchronized(DECODE_LOCK) {
                    if((data.needsMatrixTransform()) || (exifRotation != 0)) {
                        localconst/43 = transformResult(data, localconst/43, exifRotation);
                        if(picasso.loggingEnabled) {
                            Utils.log("Hunter", "transformed", data.logId());
                        }
                    }
                    if(data.hasCustomTransformations()) {
                        localconst/44 = applyCustomTransformations(data.transformations, localconst/44);
                        if(picasso.loggingEnabled) {
                            Utils.log("Hunter", "transformed", data.logId(), "from custom transformations");
                        }
                    }
                }
                if(localconst/41 != null) {
                    stats.dispatchBitmapTransformed(localconst/41);
                }
            }
        }
        return localconst/41;
    }
    
    void attach(Action p1) {
        // :( Parsing error. Please contact me.
    }
    
    void detach(Action p1) {
        boolean picasso.loggingEnabled = 0x0;
        if(action == p1) {
            action = 0x0;
            0x0 = 0x1;
        } else if(actions != null) {
            actions = actions.remove(p1);
        }
        if((picasso.loggingEnabled != null) && (p1.getPriority() == priority)) {
            priority = computeNewPriority();
        }
        if(picasso.loggingEnabled) {
            Utils.log("Hunter", "removed", p1.request.logId(), Utils.getLogIdsForHunter(this, "from "));
        }
    }
    
    private Picasso.Priority computeNewPriority() {
        actions.isEmpty() ? 0x1 : actions.isEmpty() ? 0x1 = 0x0;
        (action == null) && (actions.isEmpty() ? 0x1 : actions.isEmpty() ? 0x1 != null)) {
        }
        0x1 = 0x0;
        if(0x1 == null) {
            0x1 = Picasso.Priority.LOW;
        }
        if(action != null) {
            action = action.getPriority();
            if(actions.isEmpty() ? 0x1 : actions.isEmpty() ? 0x1 != null) {
                if(0x0 < actions.size()) {
                    0x0 = 0x0 + 0x1;
                }
            }
        }
        action = Picasso.Priority.LOW;
        localObject1 = (Action)actions.get(0x0).getPriority();
        if((Action)actions.get(0x0).ordinal() > action.ordinal()) {
            return action;
        }
        // Parsing error may occure here :(
    }
    
    boolean cancel() {
        if((action == null) && (actions != null)) {
            boolean localboolean1 = actions;
            (actions.isEmpty()) && ;
        }
        boolean localboolean2 = (future != null);
        return future.cancel(localboolean2) ? 0x1 : future.cancel(localboolean2) ? 0x1;
    }
    
    boolean isCancelled() {
        return ((future != null) && (future.isCancelled()));
    }
    
    boolean shouldRetry(boolean p1, NetworkInfo p2) {
        retryCount = retryCount > 0 ? 0x1 : 0x0;
        if(retryCount == 0) {
            return false;
        }
        retryCount = (retryCount - 0x1);
        return requestHandler.shouldRetry(p1, p2);
    }
    
    boolean supportsReplay() {
        return requestHandler.supportsReplay();
    }
    
    Bitmap getResult() {
        return result;
    }
    
    String getKey() {
        return key;
    }
    
    int getMemoryPolicy() {
        return memoryPolicy;
    }
    
    Request getData() {
        return data;
    }
    
    Action getAction() {
        return action;
    }
    
    Picasso getPicasso() {
        return picasso;
    }
    
    List getActions() {
        return actions;
    }
    
    Exception getException() {
        return exception;
    }
    
    Picasso.LoadedFrom getLoadedFrom() {
        return loadedFrom;
    }
    
    Picasso.Priority getPriority() {
        return priority;
    }
    
    static void updateThreadName(Request p1) {
        // :( Parsing error. Please contact me.
    }
    
    static BitmapHunter forRequest(Picasso p1, Dispatcher p2, Cache p3, Stats p4, Action p5) {
        // :( Parsing error. Please contact me.
    }
    
    static Bitmap applyCustomTransformations(List<Transformation> p1, Bitmap p2) {
        for(const/4  = 0x0, local1 = 0x0; local1 < size(); local1 = (local1 + 0x1)) {
            localint2 = (Transformation)get(local1);
            try {
                p2 = (local1 + 0x1).transform(p2);
            } catch(RuntimeException localRuntimeException3) {
                Picasso.HANDLER.post(new Runnable((local1 + 0x1) {
                    
                    public void run() {
                        RuntimeException e = transformation;
                        throw (localString1.append("Transformation ".key()).append(" crashed with exception.").toString(), e);
                    }
                }, localRuntimeException3));
                return null;
            }
            if(p2 == null) {
                localString4 = ().append("Transformation ");
                localconst/45 = ().append((local1 + 0x1).key());
                localconst/45 = (local1 + 0x1).key().append(" returned null after ");
                localconst/45 = (local1 + 0x1).key().append(local1);
                localString4 = (local1 + 0x1).key().append(" previous transformation(s).\n\nTransformation list:\n");
                for(; iterator().hasNext(); localconst/45) {
                    " previous transformation(s).\n\nTransformation list:\n".append(iterator().hasNext().key()).append(0xa);
                }
                Picasso.HANDLER.post(new Runnable(" previous transformation(s) {
                    
                    public void run() {
                        throw new NullPointerException(builder.toString());
                    }
                }.\n\nTransformation list:\n"));
                return null;
            }
            if((p2 == p2) && (p2.isRecycled())) {
                Picasso.HANDLER.post(new Runnable((local1 + 0x1) {
                    
                    public void run() {
                        String localString1 = transformation;
                        throw (localString2.append("Transformation ".key()).append(" returned input Bitmap but recycled it.").toString());
                    }
                }));
                return null;
            }
            if((p2 != p2) && (!p2.isRecycled())) {
                Picasso.HANDLER.post(new Runnable((local1 + 0x1) {
                    
                    public void run() {
                        String localString1 = transformation;
                        throw (localString2.append("Transformation ".key()).append(" mutated input Bitmap but failed to recycle the original.").toString());
                    }
                }));
                return null;
            }
        }
        return p2;
        return p2;
    }
    
    static Bitmap transformResult(Request p1, Bitmap p2, int p3) {
        // :( Parsing error. Please contact me.
    }
    
    private static boolean shouldResize(boolean p1, int p2, int p3, int p4, int p5) {
        // :( Parsing error. Please contact me.
    }
}
