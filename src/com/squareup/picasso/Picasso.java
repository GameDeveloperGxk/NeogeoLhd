/**
  * Generated by smali2java 1.0.0.558
  * Copyright (C) 2013 Hensence.com
  */

package com.squareup.picasso;

import android.content.Context;
import android.graphics.Bitmap;
import java.util.List;
import java.util.concurrent.ExecutorService;
import java.util.ArrayList;
import android.os.Handler;
import java.lang.ref.ReferenceQueue;
import android.os.Process;
import android.net.Uri;
import java.util.Map;
import android.widget.ImageView;
import android.os.Looper;
import java.util.Collections;
import java.util.WeakHashMap;
import android.widget.RemoteViews;
import java.util.Collection;
import java.io.File;
import java.util.Iterator;

public class Picasso {
    static final String TAG = "Picasso";
    final Cache cache;
    private final Picasso.CleanupThread cleanupThread;
    final Context context;
    final Bitmap.Config defaultBitmapConfig;
    final Dispatcher dispatcher;
    boolean indicatorsEnabled;
    private final Picasso.Listener listener;
    volatile boolean loggingEnabled;
    final ReferenceQueue<Object> referenceQueue;
    private final List<RequestHandler> requestHandlers;
    private final Picasso.RequestTransformer requestTransformer;
    boolean shutdown;
    final Stats stats;
    final Map<Object, Action> targetToAction;
    final Map<ImageView, DeferredRequestCreator> targetToDeferredRequestCreator;
    static final Handler HANDLER = new Handler(Looper.getMainLooper() {
        
        public void handleMessage(Message p1) {
            switch(p1.what) {
                case 8:
                {
                    int (List)p1.what = p1.obj;
                    for(int local1 = 0x0; local1 < (List)p1.what.size(); local1 = (local1 + 0x1)) {
                        localint3 = (BitmapHunter)(List)p1.what.get(local1);
                        (local1 + 0x1).picasso.complete((local1 + 0x1));
                    }
                    case 3:
                    {
                        Object localObject4 = p1.obj;
                        if((Action)(List)p1.what.getPicasso().loggingEnabled) {
                            Utils.log("Main", "canceled", (Action)(List)p1.what.request.logId(), "target got garbage collected");
                        }
                        break;
                    }
                    case 13:
                    {
                        int (List)(List)p1.what = p1.obj;
                        for(int local2 = 0x0; local2 < (List)(List)p1.what.size(); local2 = (local2 + 0x1)) {
                            localString5 = (Action)(List)(List)p1.what.get(local2);
                            (local2 + 0x1).picasso.resumeAction((local2 + 0x1));
                            throw new AssertionError("Unknown handler message received: " + p1.what);
                        }
                    }
                    break;
                }
            }
        }
    });
    static volatile Picasso singleton = 0x0;
    
    Picasso(Context p1, Dispatcher p2, Cache p3, Picasso.Listener p4, Picasso.RequestTransformer p5, List<RequestHandler> p6, Stats p7, Bitmap.Config p8, boolean p9, boolean p10) {
        context = p1;
        dispatcher = p2;
        cache = p3;
        listener = p4;
        requestTransformer = p5;
        defaultBitmapConfig = p8;
        ReferenceQueue referenceQueue = 0x7;
        p6 != null ? p6.size() : p6.size() = 0x0;
        ArrayList HANDLER = new ArrayList((p6 != null ? p6.size() : p6.size() + referenceQueue));
        HANDLER.add(new ResourceRequestHandler(p1));
        if(p6 != null) {
            localArrayList1.addAll(p6);
        }
        HANDLER.add(new ContactsPhotoRequestHandler(p1));
        HANDLER.add(new MediaStoreRequestHandler(p1));
        HANDLER.add(new ContentStreamRequestHandler(p1));
        HANDLER.add(new AssetRequestHandler(p1));
        HANDLER.add(new FileRequestHandler(p1));
        HANDLER.add(new NetworkRequestHandler(p2.downloader, p7));
        requestHandlers = Collections.unmodifiableList(HANDLER);
        stats = p7;
        targetToAction = new WeakHashMap();
        targetToDeferredRequestCreator = new WeakHashMap();
        indicatorsEnabled = p9;
        loggingEnabled = p10;
        referenceQueue = new ReferenceQueue();
        cleanupThread = new Picasso.CleanupThread(referenceQueue, HANDLER);
        cleanupThread.start();
    }
    
    public void cancelRequest(ImageView p1) {
        cancelExistingRequest(p1);
    }
    
    public void cancelRequest(Target p1) {
        cancelExistingRequest(p1);
    }
    
    public void cancelRequest(RemoteViews p1, int p2) {
        cancelExistingRequest(new RemoteViewsAction.RemoteViewsTarget(p1, p2));
    }
    
    public void cancelTag(Object p1) {
        Utils.checkMain();
        ArrayList localArrayList2 = new ArrayList(targetToAction.values());
        for(Collection  = 0x0, localCollection1 = 0x0; localCollection1 < localArrayList2.size(); localCollection1 = (localCollection1 + 0x1)) {
            localint3 = (Action)localArrayList2.get(localCollection1);
            if((localCollection1 + 0x1).getTag().equals(p1)) {
                cancelExistingRequest((localCollection1 + 0x1).getTarget());
            }
        }
    }
    
    public void pauseTag(Object p1) {
        dispatcher.dispatchPauseTag(p1);
    }
    
    public void resumeTag(Object p1) {
        dispatcher.dispatchResumeTag(p1);
    }
    
    public RequestCreator load(Uri p1) {
        return new RequestCreator(this, p1, 0x0);
    }
    
    public RequestCreator load(String p1) {
        if(p1 == null) {
            return new RequestCreator(this, 0x0, 0x0);
        }
        if(p1.trim().length() == 0) {
            throw new IllegalArgumentException("Path must not be empty.");
        }
        return load(Uri.parse(p1));
    }
    
    public RequestCreator load(File p1) {
        if(p1 == null) {
            return new RequestCreator(this, 0x0, 0x0);
        }
        return load(Uri.fromFile(p1));
    }
    
    public RequestCreator load(int p1) {
        if(p1 == 0) {
            throw new IllegalArgumentException("Resource ID must not be zero.");
        }
        return new RequestCreator(this, 0x0, p1);
    }
    
    public void invalidate(Uri p1) {
        if(p1 == null) {
            new IllegalArgumentException("uri == null");
            throw localIllegalArgumentException1;
        }
        cache.clearKeyUri(p1.toString());
    }
    
    public void invalidate(String p1) {
        if(p1 == null) {
            new IllegalArgumentException("path == null");
            throw localIllegalArgumentException1;
        }
        invalidate(Uri.parse(p1));
    }
    
    public void invalidate(File p1) {
        if(p1 == null) {
            new IllegalArgumentException("file == null");
            throw localIllegalArgumentException1;
        }
        invalidate(Uri.fromFile(p1));
    }
    
    public boolean isDebugging() {
        return ((areIndicatorsEnabled()) && (isLoggingEnabled()));
    }
    
    public void setDebugging(boolean p1) {
        setIndicatorsEnabled(p1);
    }
    
    public void setIndicatorsEnabled(boolean p1) {
        indicatorsEnabled = p1;
    }
    
    public boolean areIndicatorsEnabled() {
        return indicatorsEnabled;
    }
    
    public void setLoggingEnabled(boolean p1) {
        loggingEnabled = p1;
    }
    
    public boolean isLoggingEnabled() {
        return loggingEnabled;
    }
    
    public StatsSnapshot getSnapshot() {
        return stats.createSnapshot();
    }
    
    public void shutdown() {
        if(this == singleton) {
            throw new UnsupportedOperationException("Default singleton instance cannot be shutdown.");
        }
        if(shutdown) {
            return;
        }
        cache.clear();
        cleanupThread.shutdown();
        stats.shutdown();
        dispatcher.shutdown();
        for(; targetToDeferredRequestCreator.values().iterator().hasNext(); localboolean1) {
            targetToDeferredRequestCreator.values().iterator().hasNext().cancel();
        }
        targetToDeferredRequestCreator.clear();
        shutdown = true;
    }
    
    List getRequestHandlers() {
        return requestHandlers;
    }
    
    Request transformRequest(Request p1) {
        requestTransformer = requestTransformer.transformRequest(p1);
        if(requestTransformer == null) {
            String localString1 = requestTransformer;
            throw (localString2.append("Request transformer ".getClass().getCanonicalName()).append(" returned null for ").append(p1).toString());
        }
        return requestTransformer;
    }
    
    void defer(ImageView p1, DeferredRequestCreator p2) {
        targetToDeferredRequestCreator.put(p1, p2);
    }
    
    void enqueueAndSubmit(Action p1) {
        // :( Parsing error. Please contact me.
    }
    
    void submit(Action p1) {
        dispatcher.dispatchSubmit(p1);
    }
    
    Bitmap quickMemoryCacheCheck(String p1) {
        cache = cache.get(p1);
        if(cache != null) {
            stats.dispatchCacheHit();
            return cache;
        }
        stats.dispatchCacheMiss();
        return cache;
    }
    
    void complete(BitmapHunter p1) {
        // :( Parsing error. Please contact me.
    }
    
    void resumeAction(Action p1) {
        boolean loggingEnabled = 0x0;
        if(MemoryPolicy.shouldReadFromMemoryCache(p1.memoryPolicy)) {
            localString1 = quickMemoryCacheCheck(p1.getKey());
        }
        if(loggingEnabled != null) {
            deliverAction(loggingEnabled, Picasso.LoadedFrom.MEMORY, p1);
            if(loggingEnabled) {
                Utils.log("Main", "completed", p1.request.logId(), "from " + Picasso.LoadedFrom.MEMORY);
            }
            return;
        }
        enqueueAndSubmit(p1);
        if(loggingEnabled) {
            Utils.log("Main", "resumed", p1.request.logId());
        }
    }
    
    private void deliverAction(Bitmap p1, Picasso.LoadedFrom p2, Action p3) {
        if(p3.isCancelled()) {
            return;
        }
        if(!p3.willReplay()) {
            targetToAction.remove(p3.getTarget());
        }
        if(p1 != null) {
            if(p2 == null) {
                throw new AssertionError("LoadedFrom cannot be null.");
            }
            p3.complete(p1, p2);
            if(loggingEnabled) {
                Utils.log("Main", "completed", p3.request.logId(), "from " + p2);
            }
            return;
        }
        p3.error();
        if(loggingEnabled) {
            Utils.log("Main", "errored", p3.request.logId());
        }
    }
    
    private void cancelExistingRequest(Object p1) {
        // :( Parsing error. Please contact me.
    }
    
    class CleanupThread extends Thread {
        private final Handler handler;
        private final ReferenceQueue<Object> referenceQueue;
        
        CleanupThread(ReferenceQueue<Object> p1, Handler p2) {
            referenceQueue = p1;
            handler = p2;
            setDaemon(true);
            setName("Picasso-refQueue");
        }
        
        public void run() {
            // :( Parsing error. Please contact me.
        }
        
        void shutdown() {
            interrupt();
        }
    }
    
    public static Picasso with(Context p1) {
        if(singleton == null) {
            synchronized(Picasso.class) {
                if(singleton == null) {
                    singleton = new Picasso.Builder(p1).build();
                }
            }
        }
        return singleton;
    }
    
    public static void setSingletonInstance(Picasso p1) {
        synchronized(Picasso.class) {
            if(singleton != null) {
                throw new IllegalStateException("Singleton instance already exists.");
            }
            singleton = p1;
        }
    }
}
